# 刷题记录

## Hot100

### 1. 两数之和

问题不难，用哈希来做（出错的点在于，一般至少遍历到第二个才出结果，所以先返回的应该是哈希表内找到的元素的下标，才是当前下标）

对于map数据结构不熟悉 / 数组返回结果不熟悉

### 2. 两数相加

递归做法：（创造新节点）

迭代做法：创建哨兵

### 3. 无重复字符的最长字串

创建一个表维护 字符与它的实际位置

左右指针，遍历右指针，如果出现重复字符，左指针跟新为表里位置的下一个位置。没有重复字符则添加到表里。right-left+1得到当前字串长度，取最大值

### 4. 寻找两个正序数组的中位数（*）

根据总数量，其实理解成另一种模式的寻找整个的，“第k大个数”

### 5. 最长回文子串

使用动态规划 dp[i][j] == true 代表 下标i 到 j的子串为回文子串

### 11. 乘最多水的容器

左右指针

### 15. 三数之和

由于是返回列表内的元素，不是下标，排序，然后双指针判断

主要注意的第一个是优化情况

第二个是List的一些插入方法：

ans.add(List.of(nums[i], nums[j], nums[k]));

### 17. 电话号码的字母组合

采用回溯的做法

**定义** ：回溯是一种**试探 + 撤销**的搜索策略。它常常依赖 DFS 作为遍历方式，在走到某一步发现“不行”或“到头”时，退回上一步，尝试别的选择。

可以这样打个比方：

* **DFS** = 你走迷宫时的“走法” → 一直往一条路走到尽头再回来。
* **回溯** = 你发现走不通时的“撤销策略” → 回到分岔口换条路。

在 **电话号码字母组合**题目中：

* DFS：控制“从第几位数字走到第几位数字”。
* 回溯：控制“当前位换不同的字母，组合出所有可能”。

### 19. 删除链表的倒数第 N 个结点

采用快慢指针先定位到要删除节点前的位置

然后快慢指针同时前进直到快指针结束，那么这个时候慢指针刚好到达要删除节点前的位置，然后slow.next = slow.next.next;

最后返回dummy.next

### 20. 有效的括号

创建deque，只要是左括号就放入

然后如果不是左括号，就判断pop出来的符合是否与当前的符号匹配，不然返回false

最终判断deque是否为空（即所有符号匹配成功）

### 21. 合并两个有序列表：

while循环判断两个链表不为空，根据val大小分别利用cur去指向，每次指完记得cur要钱前进。由于是升序链表，最后加上剩下的还有node的。

### 22. 括号生成（*）
